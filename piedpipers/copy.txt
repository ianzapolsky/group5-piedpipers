
  // wanted rats array for optimization of the greedy piper behavior
  int[] wantedRats;
  Point[] pipers;
  Point[] rats;
  Point[] futureRats;
  boolean[] piperMusic;
  Point[] previousRats;
  int chasingCutoff = 2;


//////////////


  public void init() {
    thetas = new int[npipers];
    magnetId = 0;
    wantedRats = new int[npipers];
    previousRats = new Point[nrats];
    futureRats = new Point[nrats];
    for (int i = 0; i < nrats; i++) {
      previousRats[i] = new Point();
      futureRats[i] = new Point();
    }
  }

//////////////

    // endgame
    if (haveAllRats()) {
      if (backAtGate) {
        return moveTo(leftMid);
      }
      else {
        if (distance(currentLocation, gate) < .5)
          backAtGate = true;
        return moveTo(gate);
      }
    }
    // calculate future rats' location before move
    for(int i = 0; i < nrats; i++){
      futureRats[i] = predictLocation(i);
    }

//////////////

  // return the closest rat not under the influence of the piper
  int closestRatIndex() {
    int closestRatIndex = -1;
    double leastDist = Double.MAX_VALUE;
    for (int i = 0; i < rats.length; i++) {
      double currentLocationDist = distance(currentLocation, futureRats[i]);
      if (Math.max(currentLocationDist, distance(rats[i], futureRats[i])) < leastDist && isFreeRat(i) && movingTowardsMe(pipers[id], previousRats[i], rats[i], futureRats[i])) {
        closestRatIndex = i;
	leastDist = currentLocationDist;
      }
    }
    return closestRatIndex;
  }







